import { z } from "@hono/zod-openapi";
import {
	integer,
	jsonb,
	pgTable,
	real,
	serial,
	text,
	timestamp,
	unique,
	varchar,
} from "drizzle-orm/pg-core";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { zodToJsonSchema } from "zod-to-json-schema";

// Define enums
export const contentType = z.enum([
	"IMAGE",
	"VIDEO",
	"AUDIO",
	"DOCUMENT",
	"OTHER",
]);
export type ContentType = z.infer<typeof contentType>;

export const contentStatus = z.enum([
	"PENDING",
	"ACTIVE",
	"ARCHIVED",
	"DELETED",
]);
export type ContentStatus = z.infer<typeof contentStatus>;

// Define base schemas that will be reused
// Note: These are internal and not directly exposed via OpenAPI here.
const contentBaseSchemaInternal = z.object({
	name: z.string().min(1).max(500),
	type: contentType,
	path: z.string().min(1),
	status: contentStatus,
	hash: z.string().optional(),
	url: z.string().optional(),
	format: z.string().optional(),
	size: z.number().optional(),
	width: z.number().optional(),
	height: z.number().optional(),
	meta: z.any().optional().nullable(),
});

const contentSourceBaseSchemaInternal = z.object({
	contentId: z.number(),
	type: z.string().min(1),
	value: z.string().min(1),
});

// Database tables
export const content = pgTable("content", {
	id: serial("id").primaryKey(),
	name: varchar("name", { length: 500 }).notNull(),
	type: text("type").notNull().default("OTHER"),
	hash: text("hash"),
	path: text("path").notNull(),
	format: text("format"),
	size: integer("size"),
	status: text("status").$type<ContentStatus>().notNull().default("PENDING"),
	meta: jsonb("meta"),
	variants: jsonb("variants"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: "date" })
		.defaultNow()
		.notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: "date" })
		.defaultNow()
		.notNull(),
});

export const contentSource = pgTable("content_source", {
	id: serial("id").primaryKey(),
	contentId: integer("content_id")
		.notNull()
		.references(() => content.id),
	type: text("type").notNull(),
	value: text("value").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: "date" })
		.defaultNow()
		.notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: "date" })
		.defaultNow()
		.notNull(),
});

// --- NEW Metadata Tables ---

export const contentImageMeta = pgTable(
	"content_image_meta",
	{
		id: serial("id").primaryKey(),
		contentId: integer("content_id")
			.notNull()
			.references(() => content.id, { onDelete: "cascade" }),
		width: integer("width").notNull(),
		height: integer("height").notNull(),
	},
	(table) => ({
		unq_content_id: unique().on(table.contentId),
	}),
);

export const contentVideoMeta = pgTable(
	"content_video_meta",
	{
		id: serial("id").primaryKey(),
		contentId: integer("content_id")
			.notNull()
			.references(() => content.id, { onDelete: "cascade" }),
		width: integer("width").notNull(),
		height: integer("height").notNull(),
		duration: real("duration").notNull(),
		codec: text("codec"),
		bitrate: integer("bitrate"),
		thumbnailContentId: integer("thumbnail_content_id").references(
			() => content.id,
			{
				onDelete: "set null",
			},
		),
	},
	(table) => ({
		unq_content_id: unique().on(table.contentId),
	}),
);

export const contentAudioMeta = pgTable(
	"content_audio_meta",
	{
		id: serial("id").primaryKey(),
		contentId: integer("content_id")
			.notNull()
			.references(() => content.id, { onDelete: "cascade" }),
		duration: real("duration").notNull(),
		codec: text("codec"),
		bitrate: integer("bitrate"),
		channels: integer("channels"),
	},
	(table) => ({
		unq_content_id: unique().on(table.contentId),
	}),
);

// --- Helper Function for OpenAPI Registration with zod-to-json-schema ---
const registerSchema = <T extends z.ZodTypeAny>(
	name: string,
	schema: T,
	description?: string,
) => {
	// Generate the JSON schema using zod-to-json-schema
	// Use the basePath option matching the GitHub issue's working example for lazy types
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const jsonSchema: Record<string, unknown> = zodToJsonSchema(schema, {
		basePath: [`#/components/schemas/${name}`], // Use basePath for defining the schema location
		definitionPath: "components/schemas", // Keep definitionPath to ensure nested schemas are placed correctly
		// name: name, // basePath usually makes explicit name redundant here
		// $refStrategy: 'components', // basePath implies component references
	});

	// Remove the top-level $ref generated by zod-to-json-schema with basePath,
	// as Hono's .openapi() adds its own reference structure.
	// Keep other generated properties.
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	const { $ref, ...restJsonSchema } = jsonSchema as Record<string, unknown>;

	// Use the explicitly provided description if available, otherwise undefined.
	const finalDescription = description;

	return schema.openapi(name, {
		...restJsonSchema, // Spread the rest of the generated schema properties
		// Add the explicit description back if it was provided
		...(finalDescription && { description: finalDescription }),
	});
};

// --- Zod Schema for a single parsed variant (API Output) ---
const VariantSchemaRaw = z.object({
	label: z.string(),
	path: z.string(),
	url: z.string().url(),
	width: z.number().optional().nullable(),
	height: z.number().optional().nullable(),
	format: z.string().optional().nullable(),
	size: z.number().optional().nullable(),
});

export const VariantSchema = registerSchema(
	"Variant",
	VariantSchemaRaw,
	"Details of a single content variant (e.g., a resized image or transcoded video).",
);
export type Variant = z.infer<typeof VariantSchema>;

// --- Generate RAW Zod schemas from Drizzle tables (Internal Use) ---
const selectContentSchemaRaw = createSelectSchema(content);
const insertContentSchemaRaw = createInsertSchema(content).required({
	name: true,
	path: true,
});
const patchContentSchemaRaw = createInsertSchema(content).partial();

const selectContentImageMetaSchemaRaw = createSelectSchema(contentImageMeta);
const insertContentImageMetaSchemaRaw = createInsertSchema(contentImageMeta);

const selectContentVideoMetaSchemaRaw = createSelectSchema(contentVideoMeta);
const insertContentVideoMetaSchemaRaw = createInsertSchema(contentVideoMeta);

const selectContentAudioMetaSchemaRaw = createSelectSchema(contentAudioMeta);
const insertContentAudioMetaSchemaRaw = createInsertSchema(contentAudioMeta);

const selectContentSourceSchemaRaw = createSelectSchema(contentSource);
const insertContentSourceSchemaRaw = createInsertSchema(contentSource);
const patchContentSourceSchemaRaw = createInsertSchema(contentSource).partial();

// --- Define the API OUTPUT schemas ---

// Schemas for the structured metadata (omitting DB-specific IDs)
const apiImageMetaSchemaRaw = selectContentImageMetaSchemaRaw.omit({
	id: true,
	contentId: true,
});
const apiVideoMetaSchemaRaw = selectContentVideoMetaSchemaRaw.omit({
	id: true,
	contentId: true,
});
const apiAudioMetaSchemaRaw = selectContentAudioMetaSchemaRaw.omit({
	id: true,
	contentId: true,
});

// Register metadata schemas for OpenAPI
export const apiImageMetaSchema = registerSchema(
	"ImageMeta",
	apiImageMetaSchemaRaw,
	"Metadata specific to image content.",
);
export const apiVideoMetaSchema = registerSchema(
	"VideoMeta",
	apiVideoMetaSchemaRaw,
	"Metadata specific to video content.",
);
export const apiAudioMetaSchema = registerSchema(
	"AudioMeta",
	apiAudioMetaSchemaRaw,
	"Metadata specific to audio content.",
);

// Base schema common to all API responses
const selectContentBaseSchemaRaw = z.object({
	id: selectContentSchemaRaw.shape.id,
	name: selectContentSchemaRaw.shape.name,
	// type: will be added by the union discriminator
	hash: selectContentSchemaRaw.shape.hash.optional().nullable(),
	path: selectContentSchemaRaw.shape.path.optional().nullable(),
	format: selectContentSchemaRaw.shape.format.optional().nullable(),
	size: selectContentSchemaRaw.shape.size.optional().nullable(),
	status: selectContentSchemaRaw.shape.status,
	meta: selectContentSchemaRaw.shape.meta, // Keep the unstructured meta fallback
	createdAt: selectContentSchemaRaw.shape.createdAt.optional().nullable(),
	updatedAt: selectContentSchemaRaw.shape.updatedAt.optional().nullable(),

	// Dynamically generated fields
	url: z
		.string()
		.url()
		.openapi({ description: "URL to the original content file" })
		.optional()
		.nullable(),
	variants: z
		.array(VariantSchema) // Reference the registered VariantSchema
		.openapi({ description: "Array of available content variants with URLs" })
		.optional()
		.nullable(),
});

// Register the base schema for OpenAPI
const selectContentBaseSchema = registerSchema(
	"_SelectContentBase", // Using underscore convention for internal/base schema
	selectContentBaseSchemaRaw,
);

// The final discriminated union for API output
// Extend the registered base schema
export const selectContentSchema = registerSchema(
	"ContentDetails",
	z.discriminatedUnion("type", [
		selectContentBaseSchema.extend({
			type: z.literal(contentType.enum.IMAGE),
			imageMeta: apiImageMetaSchema, // Reference registered ImageMeta schema
		}),
		selectContentBaseSchema.extend({
			type: z.literal(contentType.enum.VIDEO),
			videoMeta: apiVideoMetaSchema, // Reference registered VideoMeta schema
		}),
		selectContentBaseSchema.extend({
			type: z.literal(contentType.enum.AUDIO),
			audioMeta: apiAudioMetaSchema, // Reference registered AudioMeta schema
		}),
		selectContentBaseSchema.extend({
			type: z.literal(contentType.enum.DOCUMENT),
			// No specific structured meta for DOCUMENT yet
		}),
		selectContentBaseSchema.extend({
			type: z.literal(contentType.enum.OTHER),
			// No specific structured meta for OTHER yet
		}),
	]),
	"Detailed information about a content item. The structure of metadata fields (`imageMeta`, `videoMeta`, `audioMeta`) depends on the `type`.",
);

// Export the inferred type for usage
export type SelectContent = z.infer<typeof selectContentSchema>;

// --- API INPUT / DB Interaction Schemas ---

// Use the registration helper for insert/patch/source schemas as well
export const insertContentSchema = registerSchema(
	"CreateContent",
	insertContentSchemaRaw,
	"Schema for creating new content entries.",
);
export const patchContentSchema = registerSchema(
	"UpdateContent",
	patchContentSchemaRaw,
	"Schema for partially updating existing content entries.",
);

export const selectContentSourceSchema = registerSchema(
	"ContentSource",
	selectContentSourceSchemaRaw,
	"Schema representing a source associated with a content item.",
);
export const insertContentSourceSchema = registerSchema(
	"CreateContentSource",
	insertContentSourceSchemaRaw,
	"Schema for creating a new content source.",
);
export const patchContentSourceSchema = registerSchema(
	"UpdateContentSource",
	patchContentSourceSchemaRaw,
	"Schema for partially updating an existing content source.",
);

// Register metadata insert schemas if needed for specific API endpoints
export const insertContentImageMetaSchema = registerSchema(
	"CreateImageMeta",
	insertContentImageMetaSchemaRaw,
	"Schema for creating image metadata.",
);
export const insertContentVideoMetaSchema = registerSchema(
	"CreateVideoMeta",
	insertContentVideoMetaSchemaRaw,
	"Schema for creating video metadata.",
);
export const insertContentAudioMetaSchema = registerSchema(
	"CreateAudioMeta",
	insertContentAudioMetaSchemaRaw,
	"Schema for creating audio metadata.",
);

// Note: Raw select metadata schemas (e.g., selectContentImageMetaSchemaRaw)
// are not typically registered directly for OpenAPI unless you have endpoints
// that return *only* that specific metadata structure.
// The combined structure is handled by ContentDetails.

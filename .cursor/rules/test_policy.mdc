---
description: Unit, integration, and e2e tests
globs: test/**
alwaysApply: true
---
# Test Overview

Our tests are divided into three primary categories:

- **Unit Tests:**  
  Test the smallest units of code (e.g. individual React components, utility functions, or Express route handlers) in isolation. These tests run quickly and are designed to work in any environment.

- **Integration Tests:**  
  Verify interactions between modules or services within the application. For example, these tests might ensure that your Express API correctly interacts with a database or that your React components integrate well with shared providers.

- **End-to-End (E2E) Tests:**  
  Simulate real user scenarios by testing the entire application—from the user interface (React) through the backend (Express) and any external systems. These tests are implemented using Playwright and provide confidence that critical user journeys function as expected.


## Test Policy

### Conventions
- **Structure:**  
  Every test should clearly follow a **GIVEN / WHEN / THEN** pattern. This ensures that the test focuses on the behavior of the code under test rather than on internal implementation details.
  
- **Readability:**  
  Write tests so that they are self-explanatory. Future maintainers should quickly grasp what the test is validating.

### Unit Tests
**Purpose:**  
To verify the smallest units of functionality in isolation.

**When to Use:**
- For testing complex algorithms, data transformations, and business logic.
- For validating utility functions or shared components in React and Express.
- When the input/output relationship is clear and can be tested as a “black box.”
- To provide immediate feedback during development, reducing the need for manual testing.

**Characteristics:**  
- Fast, focused, and reliable.
- Co-located with the source code to keep the component and its tests together—ideal for exporting mini programs or standalone components.

**Avoid:**
- Over-mocking dependencies, such as databases or external APIs. Instead, test with real code as much as possible.
- Tightly coupling tests to implementation details. Focus on the outcome, not the process.

### Integration Tests
**Purpose:**  
To confirm that different parts of the application (e.g. React components with context providers or Express API endpoints with a live database) work together as expected.

**When to Use:**
- To verify interactions between services or components.
- To test end-to-end data flow through the application (e.g. a POST request in Express updating the database and reflecting changes in a React component).
- When unit tests alone cannot confirm the behavior of a composite operation.

**Characteristics:**  
- Slower than unit tests, as they might require starting a local database or spinning up other service containers.
- Ensure that real integrations (e.g. network calls, database operations) function as expected.

**Avoid:**
- Overly broad tests that cover too much functionality at once.
- Duplicating scenarios that are already tested by unit tests.

### End-to-End (E2E) Tests
**Purpose:**  
To simulate user scenarios and validate that the entire application (UI, backend, external systems) functions correctly.

**When to Use:**
- To validate the most critical user journeys.
- To ensure that changes to one part of the system do not break the overall application.
- To catch issues that might not be evident in lower-level tests.

**Characteristics:**  
- Slowest to run due to full-stack execution.
- Can be complex to maintain, but are extremely valuable for catching real-world issues.

**Avoid:**
- An excessive number of E2E tests that could slow down development.
- Duplication of coverage already provided by unit or integration tests. Focus on the critical paths only.

---

## React + Express Specific Considerations

- **Co-located Tests for React Components:**  
  Each React component should have its test file (e.g. `MyComponent.jsx` alongside `MyComponent.test.jsx`). This makes it easier to flatten and export each component as an independent mini program.

- **Express Backend Tests:**  
  Write tests for Express routes and middleware as unit tests when testing logic in isolation, or as integration tests when verifying behavior with a live database or external API. Co-locate tests with related modules where practical.

- **Shared Providers & Contexts:**  
  For integration tests, ensure that any shared state (like React context providers or Express middleware stacks) is configured similarly to production. This might involve setting up temporary instances of services (via Docker containers) or configuring test-specific environment variables.

- **CI/CD and Docker:**  
  Our CI/CD (via GitHub Actions) runs tests inside Docker containers to match our production environment. Ensure your CI configuration:
  - Spins up necessary services (e.g., test databases) before running integration tests.
  - Runs unit tests quickly using Vitest and defers slower E2E tests to separate jobs.
  - Caches dependencies (using pnpm’s cache) to speed up builds.

- **Avoid Over-Mocking:**  
  Where possible, use real services and components to validate functionality. Reserve mocking for boundaries where external systems are involved (e.g. third-party APIs).

---

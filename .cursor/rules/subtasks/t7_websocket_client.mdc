---
description: 
globs: 
alwaysApply: false
---

# WebSocket Integration with TanStack Query and Hono for Batch Captioning

## Architecture Overview

This design implements real-time updates for the batch caption queue using WebSockets, with Hono on the backend and TanStack Query on the frontend.

```
┌─────────────────┐      HTTP REST     ┌────────────────┐
│                 │◄───────────────────┤                │
│  Hono Backend   │                    │  React Client  │
│  (Data Service) │                    │                │
│                 │      WebSocket     │  TanStack      │
│                 │◄───────────────────┤  Query         │
└─────────────────┘                    └────────────────┘
```

## 1. Backend WebSocket Server with Hono

```typescript
// servers/data_service/src/websocket/server.ts

import { Hono } from 'hono';
import { Server } from 'ws';
import { EventEmitter } from 'events';
import { JobEvent, ClientMessage } from './event-types';

// Event bus for job events
export const jobEventBus = new EventEmitter();

// Export WebSocket server instance 
let wss: Server;

export function setupWebSocketServer(app: Hono, port: number) {
  // Create WebSocket server
  wss = new Server({ noServer: true });
  
  // Track connected clients
  const clients = new Set<WebSocket>();
  
  // Handle new connections
  wss.on('connection', (ws: WebSocket) => {
    clients.add(ws);
    
    // Send welcome message
    ws.send(JSON.stringify({
      type: 'CONNECTED',
      data: { message: 'Connected to graphcap Batch Queue' }
    }));
    
    // Handle incoming messages
    ws.on('message', (message: string) => {
      try {
        const parsedMessage = JSON.parse(message) as ClientMessage;
        
        switch (parsedMessage.type) {
          case 'PING':
            ws.send(JSON.stringify({ type: 'PONG', timestamp: Date.now() }));
            break;
            
          case 'SUBSCRIBE':
            // Could implement channel-based subscriptions here
            break;
            
          default:
            console.warn(`Unknown message type: ${parsedMessage.type}`);
        }
      } catch (error) {
        console.error('Error processing message:', error);
      }
    });
    
    // Handle disconnection
    ws.on('close', () => {
      clients.delete(ws);
    });
  });
  
  // Handle HTTP server upgrade
  app.use('*', async (c, next) => {
    // Store the underlying HTTP server object
    if (!c.runtime || !c.runtime.upgradeWebSocket) {
      await next();
      return;
    }
    
    // Handle WebSocket upgrade
    const upgrade = c.req.header('upgrade');
    if (upgrade && upgrade.toLowerCase() === 'websocket') {
      c.runtime.upgradeWebSocket(wss);
      return;
    }
    
    await next();
  });
  
  // Subscribe to job events and broadcast to clients
  jobEventBus.on('job_event', (event: JobEvent) => {
    const message = JSON.stringify(event);
    clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  });
  
  return wss;
}

// Function to emit job events
export function emitJobEvent(event: JobEvent) {
  jobEventBus.emit('job_event', event);
}
```

### Event Types

```typescript
// servers/data_service/src/websocket/event-types.ts

// Job status events (server to client)
export type JobStatus = 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';

export interface JobEvent {
  type: 'JOB_CREATED' | 'JOB_STARTED' | 'JOB_PROGRESS' | 'JOB_COMPLETED' | 'JOB_FAILED' | 'JOB_CANCELLED' | 'QUEUE_REORDERED';
  jobId?: string;
  data: {
    status?: JobStatus;
    progress?: number;
    totalImages?: number;
    processedImages?: number;
    estimatedTimeRemaining?: number;
    error?: string;
    queuePosition?: number;
    newOrder?: string[]; // For QUEUE_REORDERED events
  };
  timestamp: number;
}

// Client messages (client to server)
export interface ClientMessage {
  type: 'PING' | 'SUBSCRIBE';
  data?: any;
}
```

### Integration with Job Processor Service

```typescript
// servers/data_service/src/services/job-processor.ts

import { emitJobEvent } from '../websocket/server';

export class JobProcessor {
  // ... existing job processor code ...
  
  // Called when a job starts
  startJob(jobId: string, totalImages: number) {
    // ... existing code to start a job ...
    
    // Emit event for WebSocket clients
    emitJobEvent({
      type: 'JOB_STARTED',
      jobId,
      data: {
        status: 'RUNNING',
        totalImages,
        processedImages: 0,
        progress: 0,
        estimatedTimeRemaining: this.estimateTimeRemaining(jobId, totalImages, 0)
      },
      timestamp: Date.now()
    });
  }
  
  // Called when job progress updates
  updateJobProgress(jobId: string, processedImages: number, totalImages: number) {
    // ... existing code to update progress ...
    
    const progress = Math.round((processedImages / totalImages) * 100);
    
    // Emit event for WebSocket clients
    emitJobEvent({
      type: 'JOB_PROGRESS',
      jobId,
      data: {
        status: 'RUNNING',
        totalImages,
        processedImages,
        progress,
        estimatedTimeRemaining: this.estimateTimeRemaining(jobId, totalImages, processedImages)
      },
      timestamp: Date.now()
    });
  }
  
  // Called when a job item status changes
  updateItemStatus(jobId: string, itemId: string, status: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED') {
    // ... existing code to update item status ...
    
    // Get updated job progress
    const { processedItems, totalItems } = this.getJobProgress(jobId);
    
    // Emit progress event
    this.updateJobProgress(jobId, processedItems, totalItems);
  }
  
  // ... other job processor methods with events for completion, failure, etc. ...
}
```

## 2. React Frontend with TanStack Query

### WebSocket Hook

```typescript
// graphcap_studio/src/hooks/useQueueWebSocket.ts

import { useState, useEffect, useRef, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';

interface WebSocketOptions {
  url: string;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
}

export function useQueueWebSocket({
  url,
  reconnectInterval = 3000,
  maxReconnectAttempts = 5
}: WebSocketOptions) {
  const [isConnected, setIsConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState<any>(null);
  const [connectionAttempts, setConnectionAttempts] = useState(0);
  
  const wsRef = useRef<WebSocket | null>(null);
  const queryClient = useQueryClient();
  
  // Connect to WebSocket
  const connect = useCallback(() => {
    if (wsRef.current?.readyState === WebSocket.OPEN) return;
    
    try {
      const ws = new WebSocket(url);
      
      ws.onopen = () => {
        console.log('WebSocket connected');
        setIsConnected(true);
        setConnectionAttempts(0);
      };
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        setLastMessage(data);
        
        // Handle different event types
        switch (data.type) {
          case 'JOB_CREATED':
            // Invalidate queries to refresh job list
            queryClient.invalidateQueries({ queryKey: ['jobs'] });
            break;
            
          case 'JOB_STARTED':
          case 'JOB_PROGRESS':
          case 'JOB_COMPLETED':
          case 'JOB_FAILED':
          case 'JOB_CANCELLED':
            // Update specific job in cache
            queryClient.setQueryData(['job', data.jobId], (oldData: any) => {
              // If we don't have cached data, return the new data
              if (!oldData) return data.data;
              
              // Otherwise, merge with the existing data
              return {
                ...oldData,
                ...data.data,
                lastUpdated: data.timestamp
              };
            });
            
            // Also update job list if present in cache
            queryClient.setQueriesData({ queryKey: ['jobs'] }, (oldData: any) => {
              if (!oldData?.jobs) return oldData;
              
              return {
                ...oldData,
                jobs: oldData.jobs.map((job: any) => 
                  job.id === data.jobId 
                    ? { ...job, ...data.data, lastUpdated: data.timestamp }
                    : job
                )
              };
            });
            break;
            
          case 'QUEUE_REORDERED':
            // Invalidate queries to refresh job list with new order
            queryClient.invalidateQueries({ queryKey: ['jobs'] });
            break;
            
          default:
            // Handle other message types
            break;
        }
      };
      
      ws.onclose = () => {
        setIsConnected(false);
        
        // Attempt to reconnect if not manually closed
        if (connectionAttempts < maxReconnectAttempts) {
          setTimeout(() => {
            setConnectionAttempts(prev => prev + 1);
            connect();
          }, reconnectInterval);
        }
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        ws.close();
      };
      
      wsRef.current = ws;
    } catch (error) {
      console.error('Error connecting to WebSocket:', error);
    }
  }, [url, connectionAttempts, maxReconnectAttempts, reconnectInterval, queryClient]);
  
  // Send message to server
  const sendMessage = useCallback((message: any) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message));
    } else {
      console.warn('WebSocket not connected, unable to send message');
    }
  }, []);
  
  // Send ping to keep connection alive
  const sendPing = useCallback(() => {
    sendMessage({ type: 'PING', timestamp: Date.now() });
  }, [sendMessage]);
  
  // Connect on mount, disconnect on unmount
  useEffect(() => {
    connect();
    
    // Set up ping interval
    const pingInterval = setInterval(sendPing, 30000);
    
    return () => {
      clearInterval(pingInterval);
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, [connect, sendPing]);
  
  return {
    isConnected,
    lastMessage,
    sendMessage
  };
}
```

### Job List Component with WebSocket Updates

```typescript
// graphcap_studio/src/features/batch-queue/components/JobList.tsx

import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { useQueueWebSocket } from '../../../hooks/useQueueWebSocket';
import { Box, VStack, Text, Badge, Progress, Spinner } from '@chakra-ui/react';
import { JobItem } from './JobItem';

export function JobList() {
  // Query for initial job list
  const { data, isLoading, error } = useQuery({
    queryKey: ['jobs'],
    queryFn: async () => {
      const res = await fetch('/api/perspectives/batch/list');
      return res.json();
    },
    refetchInterval: 30000, // Fallback polling in case WebSocket disconnects
  });
  
  // Connect to WebSocket for real-time updates
  const { isConnected } = useQueueWebSocket({
    url: `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/api/perspectives/batch/ws`,
  });
  
  if (isLoading) {
    return <Spinner />;
  }
  
  if (error) {
    return <Text color="red.500">Error loading jobs: {error.message}</Text>;
  }
  
  return (
    <Box>
      <Box mb={2} display="flex" justifyContent="space-between" alignItems="center">
        <Text fontSize="sm">Queue Status</Text>
        <Badge colorScheme={isConnected ? 'green' : 'orange'}>
          {isConnected ? 'Live Updates' : 'Disconnected'}
        </Badge>
      </Box>
      
      {data?.jobs?.length === 0 ? (
        <Text fontSize="sm" color="gray.500" textAlign="center" py={4}>
          No jobs in queue
        </Text>
      ) : (
        <VStack spacing={3} align="stretch">
          {data?.jobs?.map((job) => (
            <JobItem key={job.id} job={job} />
          ))}
        </VStack>
      )}
    </Box>
  );
}
```

### Job Item Component

```typescript
// graphcap_studio/src/features/batch-queue/components/JobItem.tsx

import { Box, Text, Progress, HStack, Badge, IconButton, Tooltip } from '@chakra-ui/react';
import { FiX, FiRefreshCw } from 'react-icons/fi';
import { useMutation, useQueryClient } from '@tanstack/react-query';

interface JobItemProps {
  job: {
    id: string;
    status: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED';
    progress: number;
    totalImages: number;
    processedImages: number;
    estimatedTimeRemaining?: number;
    type: string;
    created_at: string;
  };
}

export function JobItem({ job }: JobItemProps) {
  const queryClient = useQueryClient();
  
  // Mutation for cancelling a job
  const cancelMutation = useMutation({
    mutationFn: async (jobId: string) => {
      const res = await fetch(`/api/perspectives/batch/cancel/${jobId}`, {
        method: 'POST'
      });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['jobs'] });
    }
  });
  
  // Mutation for retrying failed jobs
  const retryMutation = useMutation({
    mutationFn: async (jobId: string) => {
      const res = await fetch(`/api/perspectives/batch/retry-failed/${jobId}`, {
        method: 'POST'
      });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['jobs'] });
    }
  });
  
  // Format estimated time remaining
  const formatTime = (seconds?: number) => {
    if (!seconds) return 'Calculating...';
    if (seconds < 60) return `${Math.round(seconds)}s`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${Math.round(seconds % 60)}s`;
    return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
  };
  
  // Get status color
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'RUNNING': return 'blue';
      case 'COMPLETED': return 'green';
      case 'FAILED': return 'red';
      case 'CANCELLED': return 'orange';
      default: return 'gray';
    }
  };
  
  return (
    <Box 
      p={3} 
      borderWidth="1px" 
      borderRadius="md" 
      borderLeftWidth="4px"
      borderLeftColor={`${getStatusColor(job.status)}.500`}
    >
      <HStack justifyContent="space-between" mb={1}>
        <Text fontSize="sm" fontWeight="medium">Job #{job.id}</Text>
        <Badge colorScheme={getStatusColor(job.status)}>
          {job.status}
        </Badge>
      </HStack>
      
      <Text fontSize="xs" color="gray.500" mb={2}>
        {new Date(job.created_at).toLocaleString()} · {job.type}
      </Text>
      
      {job.status === 'RUNNING' && (
        <>
          <Progress 
            value={job.progress} 
            size="sm" 
            colorScheme="blue" 
            mb={1}
            borderRadius="full"
          />
          <HStack justifyContent="space-between" fontSize="xs">
            <Text>
              {job.processedImages} / {job.totalImages} images
            </Text>
            <Text>{formatTime(job.estimatedTimeRemaining)} remaining</Text>
          </HStack>
        </>
      )}
      
      {(job.status === 'PENDING' || job.status === 'RUNNING') && (
        <HStack justifyContent="flex-end" mt={2}>
          <Tooltip label="Cancel Job">
            <IconButton
              aria-label="Cancel Job"
              icon={<FiX />}
              size="sm"
              variant="ghost"
              colorScheme="red"
              isLoading={cancelMutation.isPending}
              onClick={() => cancelMutation.mutate(job.id)}
            />
          </Tooltip>
        </HStack>
      )}
      
      {job.status === 'FAILED' && (
        <HStack justifyContent="flex-end" mt={2}>
          <Tooltip label="Retry Failed Items">
            <IconButton
              aria-label="Retry Failed Items"
              icon={<FiRefreshCw />}
              size="sm"
              variant="ghost"
              colorScheme="blue"
              isLoading={retryMutation.isPending}
              onClick={() => retryMutation.mutate(job.id)}
            />
          </Tooltip>
        </HStack>
      )}
    </Box>
  );
}
```

### Queue Panel with WebSocket Provider

```typescript
// graphcap_studio/src/features/batch-queue/components/QueuePanel.tsx

import { useState } from 'react';
import { Box, Tabs, TabList, Tab, TabPanels, TabPanel, Text, Switch, HStack, Divider } from '@chakra-ui/react';
import { useQueueWebSocket } from '../../../hooks/useQueueWebSocket';
import { JobList } from './JobList';
import { QueueStats } from './QueueStats';

export function QueuePanel() {
  const [showAdvanced, setShowAdvanced] = useState(false);
  const { isConnected } = useQueueWebSocket({
    url: `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/api/perspectives/batch/ws`,
  });
  
  return (
    <Box p={4}>
      <HStack mb={4} justifyContent="space-between">
        <Text fontSize="lg" fontWeight="bold">Batch Queue</Text>
        <HStack>
          <Text fontSize="sm">Advanced View</Text>
          <Switch 
            isChecked={showAdvanced} 
            onChange={() => setShowAdvanced(!showAdvanced)} 
            size="sm"
          />
        </HStack>
      </HStack>
      
      <Text fontSize="xs" color={isConnected ? "green.500" : "orange.500"} mb={2}>
        {isConnected ? "Connected - Live Updates" : "Connecting..."}
      </Text>
      
      <QueueStats showAdvanced={showAdvanced} />
      
      <Divider my={4} />
      
      <JobList />
    </Box>
  );
}
```

## 3. Integration and Setup

### Initialize the WebSocket Server in Hono

```typescript
// servers/data_service/src/index.ts

import { Hono } from 'hono';
import { serveStatic } from 'hono/serve-static';
import { cors } from 'hono/cors';
import { logger } from 'hono/logger';
import { setupWebSocketServer } from './websocket/server';
import { createBatchRoutes } from './routes/batch-routes';

const app = new Hono();

app.use('*', logger());
app.use('*', cors());

// Add API routes
app.route('/api/perspectives/batch', createBatchRoutes());

// Setup WebSocket Server
setupWebSocketServer(app, 32550);

// Static files
app.use('/*', serveStatic({ root: './static' }));

// Health check endpoint
app.get('/health', (c) => c.json({ status: 'ok' }));

export default app;
```

### Configure TanStack Query Provider

```typescript
// graphcap_studio/src/App.tsx

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { MainLayout } from './layouts/MainLayout';

// Create a client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30000, // 30 seconds
      retry: 1,
      refetchOnWindowFocus: true,
    },
  },
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <MainLayout />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

export default App;
```

## 4. Communication Protocol

### WebSocket Message Format

#### Server-to-Client Events
```typescript
{
  type: 'JOB_CREATED' | 'JOB_STARTED' | 'JOB_PROGRESS' | 'JOB_COMPLETED' | 'JOB_FAILED' | 'JOB_CANCELLED' | 'QUEUE_REORDERED',
  jobId?: string,
  data: {
    status?: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED',
    progress?: number,
    totalImages?: number,
    processedImages?: number,
    estimatedTimeRemaining?: number,
    error?: string,
    queuePosition?: number,
    newOrder?: string[], // For QUEUE_REORDERED events
  },
  timestamp: number
}
```

#### Client-to-Server Messages
```typescript
{
  type: 'PING' | 'SUBSCRIBE',
  data?: any,
  timestamp: number
}
```

## Benefits of This Design

1. **Real-time Updates**: Users receive immediate notifications about job status changes
2. **Reduced Server Load**: Eliminates the need for frequent polling
3. **Optimistic UI Updates**: TanStack Query enables smooth UI updates
4. **Fallback Mechanism**: Falls back to polling if WebSocket connection fails
5. **Reconnect Logic**: Automatically attempts to reconnect if connection is lost
6. **Organized Event Structure**: Clear message protocol for different event types
7. **Cache Synchronization**: Updates TanStack Query cache with WebSocket events

This architecture provides a robust foundation for real-time batch caption job tracking, giving users immediate feedback on job progress while maintaining a responsive UI.
